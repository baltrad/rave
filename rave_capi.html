<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAVE: Introduction to the RAVE C APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RAVE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Introduction to the RAVE C APIs </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >A lot of work done in RAVE is number crunching in different ways.</p>
<p >Sometimes it can be re-projecting from one area to another, other times it's more demanding algorithms that must be performed.</p>
<p >So, why have we decided to go for C instead of high-level languages like Python and Java. The easiest answer is that we had an old legacy that we have refined, but fortunately there are other reasons as well. C is fast and since some algorithms will always be demanding it's better to prepared for the worst. Another reason is that it is fairly easy to add both Python and Java APIs on top of C by using the native interface support in those languages.</p>
<p >Let's take a look at the core of the transform library (&lt;ravesrc&gt;/librave/transform).</p>
<h1><a class="anchor" id="rave_capi_1"></a>
rave_object.h</h1>
<p >C might be a bit awkward to use since you need to be careful about memory management. We have tried to make parts of this processing more easily manageable by using a concept where we are using reference counters and objects instead of pure memory allocation. This is not completely true since you still will need to allocate memory at times, but we try to facilitate this.</p>
<p >First, we have <a class="el" href="rave__object_8h.html">rave_object.h</a>. This file is essential for manipulating objects within RAVE. It is somewhat similar to how Python has implemented its object support.</p>
<p >There are five macros that are really necessary and will be used quite a lot.</p>
<ul>
<li><a class="el" href="rave__object_8h.html#a00fd96dfc33dfd5e76f437e2d6f3dba2">RAVE_OBJECT_NEW</a> This is the macro that is used for creating the objects RAVE provides. <pre class="fragment">  PolarScan_t* scan = RAVE_OBJECT_NEW(&amp;PolarScan_TYPE);
</pre></li>
<li><a class="el" href="rave__object_8h.html#a22cac20a5c563f76f1b4eb2a8d473fca">RAVE_OBJECT_RELEASE</a> This is the macro to use when you are finished with an object. <pre class="fragment">  RAVE_OBJECT_RELEASE(scan);
</pre></li>
<li><a class="el" href="rave__object_8h.html#aa7c3ecd8ecf59b99296dd44ea65c5972">RAVE_OBJECT_COPY</a> This is the macro to use when copying a reference to an object. <pre class="fragment">  RaveScan_t* copy = RAVE_OBJECT_COPY(scan);
</pre></li>
<li><a class="el" href="rave__object_8h.html#a18816c94776874539b2065267c388aed">RAVE_OBJECT_CLONE</a> This is the macro to use when cloning an an object. This will create a completley new object and it is up to the object to support the copy constructor. This means that it is essential to test if the clone has been created or not, cloning might not be supported for the provided object. <pre class="fragment">  RaveScan_t* clone = RAVE_OBJECT_CLONE(scan);
</pre></li>
<li><a class="el" href="rave__object_8h.html#a23a245cafb73c053dad4f5923d1e5d2d">RAVE_OBJECT_CHECK_TYPE</a> This macro is used for testing what type of object you are working with. <pre class="fragment">  if (RAVE_OBJECT_CHECK_TYPE(scan, &amp;PolarScan_TYPE))
</pre></li>
</ul>
<p ><b>NOTE: </b> Regardless if you are using <a class="el" href="rave__object_8h.html#a00fd96dfc33dfd5e76f437e2d6f3dba2">RAVE_OBJECT_NEW</a>, <a class="el" href="rave__object_8h.html#aa7c3ecd8ecf59b99296dd44ea65c5972">RAVE_OBJECT_COPY</a> or <a class="el" href="rave__object_8h.html#a18816c94776874539b2065267c388aed">RAVE_OBJECT_CLONE</a> you always should call <a class="el" href="rave__object_8h.html#a22cac20a5c563f76f1b4eb2a8d473fca">RAVE_OBJECT_RELEASE</a> when you are done with the object.</p>
<pre class="fragment">  PolarScan_t* src = RAVE_OBJECT_NEW(&amp;PolarScan_TYPE);   // Create a new instance
  PolarScan_t* copy = RAVE_OBJECT_COPY(src);             // same object as src (but reference count is increased)
  PolarScan_t* clone = RAVE_OBJECT_CLONE(copy);          // identical copy but not same

  // if (src == copy) evaluates to true but
  // if (src == clone) will evaluate to false.
  
  RAVE_OBJECT_RELEASE(src);                              // decrease reference count
  RAVE_OBJECT_RELEASE(copy);                             // decreases reference count and object is destroyed
  RAVE_OBJECT_RELEASE(clone);                            // decreases reference count and object is destroyed
</pre><p >If you are uncertain if you have managed to release all objects when the application terminates or if you are curious on how many pending objects you have at a particular time, the function <a class="el" href="rave__object_8h.html#a30035f109e202a1138ed3668651b9bbd">RaveCoreObject_printStatistics</a> will print it out on stderr. If you want such statistics to be printed when the application terminates, add this call during initialization of your program. </p><pre class="fragment">  if (atexit(RaveCoreObject_printStatistics) != 0) {
    fprintf(stderr, "Could not set atexit function");
  }
</pre><p >If the Python API modules are used, this has already been done so you do not need to bother.</p>
<p >There are a few more macros that might be useful when wrapping the objects for other languages or similar situations but that usage must be used with caution.</p><ul>
<li><a class="el" href="rave__object_8h.html#a7527e1406161b3e0e86fc93e3c2c62db">RAVE_OBJECT_BIND</a> Used for binding an object with some meta data <pre class="fragment">  RAVE_OBJECT_BIND(scan, boundobject);
</pre></li>
<li><a class="el" href="rave__object_8h.html#ae6f0f0685eebe2922c6d6c3d7fce3a0f">RAVE_OBJECT_UNBIND</a> Used for removing a binding. This function takes the same boundobject as was used for binding, the reason for this is to at least avoid removing a binding that not was done by the owner. Of course, it is just to get the binding and pass it in but then you are actively causing errors and you are at your own. <pre class="fragment">  RAVE_OBJECT_UNBIND(scan, boundobject);
</pre></li>
<li><a class="el" href="rave__object_8h.html#a4646a445de2a7ee78849bc7f158e3fbe">RAVE_OBJECT_ISBOUND</a> Tests if the object has a binding or not <pre class="fragment">  if (RAVE_OBJECT_ISBOUND(scan))
</pre></li>
<li><a class="el" href="rave__object_8h.html#ae13e9336afd5678c1fb4215aef89e293">RAVE_OBJECT_GETBINDING</a> Returns the current binding or NULL if there is none. As you see, in the code example we are using GETBINDING for keeping track on Python objects but it can be used for other things as well. <pre class="fragment">  PyPolarScan* this = (PyPolarScan*)RAVE_OBJECT_GETBINDING(scan);
</pre></li>
</ul>
<p >We will investigate the bindings later on in the RAVE Python API documentation. But for now, just be careful if you decide to use it. By the way, <a class="el" href="rave__object_8h.html#aa7c3ecd8ecf59b99296dd44ea65c5972">RAVE_OBJECT_COPY</a> will leave the binding as is but <a class="el" href="rave__object_8h.html#a18816c94776874539b2065267c388aed">RAVE_OBJECT_CLONE</a> will not pass it on.</p>
<h1><a class="anchor" id="rave_capi_2"></a>
rave_alloc.h</h1>
<p >This is the other API that provides some help when it comes to memory allocation. These macros basically debug all allocations you perform (if you use them). Since this is a quite heavy operation, we only debug memory if RAVE has been built with the compile-flag <b>-DRAVE_MEMORY_DEBUG</b>, otherwise it will basically be the same as calling the standard C-functions directly.</p>
<ul>
<li><a class="el" href="rave__alloc_8h.html#a85bf7bab39ffa0779b81664c3a5842c5">RAVE_MALLOC</a> - Same as malloc</li>
<li><a class="el" href="rave__alloc_8h.html#a97dfeaeb8c83ab382e4d79df384d4622">RAVE_CALLOC</a> - Same as calloc</li>
<li><a class="el" href="rave__alloc_8h.html#a96befccb5a0a3d122b7548fd777881d7">RAVE_REALLOC</a> - Same as realloc</li>
<li><a class="el" href="rave__alloc_8h.html#a0d23b5e163c7f2785f7d5e86d809f8d9">RAVE_STRDUP</a> - Same as strdup</li>
<li><a class="el" href="rave__alloc_8h.html#ace433399ebe7e1d39dd6e4160ea7e1a7">RAVE_FREE</a> - Same as free(x); x = NULL</li>
</ul>
<p >If you have enabled memory debugging, you will get notifications if you are accessing memory out of bounds, if you try to free memory != NULL that already has been freed, and so forth. However, you will still not get a dump of lost memory. To be able to get that, you will need to do one thing manually in your main program or module.</p>
<pre class="fragment">  if (atexit(rave_alloc_print_statistics) != 0) {
    fprintf(stderr, "Could not set atexit function");
  }
</pre><p >This little code segment will call the function <a class="el" href="rave__alloc_8h.html#a551a76a236c24b51b9349c20374734e0">rave_alloc_print_statistics</a> when the program exits. This is automatically supported if you are using our Python modules, but if you prefer to write your own program using the transform library you need to do this.</p>
<h1><a class="anchor" id="rave_capi_3"></a>
rave_debug.h</h1>
<p >The final header file that provides some useful macros is <a class="el" href="rave__debug_8h.html">rave_debug.h</a>. As it sounds, it contains some debug macros. Since we do not know if the system will be compiled with a compiler that can manage macros with variable argument lists, we have provided macros that can take up to four (4) arguments. If you need more, then you will need to create your own strings and pass them to an appropriate macro.</p>
<p >Some macros will always be enabled and other will only be available when compiling with <b>-DDEBUG_RAVE</b>. To be able to get the printouts you need to set a debug level by calling the function <a class="el" href="rave__debug_8h.html#a4315152776a710b6e3bcdbc8bf08a370">Rave_setDebugLevel</a>. The default level is always silent, meaning that nothing will be printed except CRITICAL errors. The levels that are possible to print out without enabling <b>-DDEBUG_RAVE</b> are:</p><ul>
<li><a class="el" href="rave__debug_8h.html#a8895ff5703ad09d158397527c9d2c3b6a4ebb5fd8d412cbe50a6943f5574a7fc8">RAVE_INFO</a> - non error-related information</li>
<li><a class="el" href="rave__debug_8h.html#a8895ff5703ad09d158397527c9d2c3b6a9e4ccbe20b68d81b67846c2b41178d10">RAVE_WARNING</a> - warnings that not will affect the result in any serious way</li>
<li><a class="el" href="rave__debug_8h.html#a8895ff5703ad09d158397527c9d2c3b6a301920a7ad5e7030f03106b7c2e45623">RAVE_ERROR</a> - this is starting to get a bit more serious but it might occur, like trying to open a file that does not exist</li>
<li><a class="el" href="rave__debug_8h.html#a8895ff5703ad09d158397527c9d2c3b6a106a3d0328f0ac65bf8161f032e51d2f">RAVE_CRITICAL</a> - these are really bad and should be used with care, this might be that memory allocation fails or other conditions that really not should occur during the life cycle of the application. So, do not use this if a file is missing or not is readable. One should also be aware that a critical error might indicate that it really is time to shut down the application and if someone has rerouted the error reporting to their own function, they might actually abort the application.</li>
</ul>
<p >Speaking of which, you are able to send all printouts to your own logger. This is done by using <a class="el" href="rave__debug_8h.html#a8ad6c0fb9538d92f2f275d1857f040c5">Rave_setDebugFunction</a>.</p>
<pre class="fragment">static void MY_debugFunction(char* filename, int lineno, Rave_Debug lvl,  const char* fmt, ...)
{
  if (lvl == RAVE_CRITICAL) {
    fprintf(stderr, "%s:%d caused a CRITICAL ERROR\n", filename, lineno);
    abort();
  }
}

....

Rave_setDebugFunction(MY_debugFunction);</pre><p >There is another thing that also can cause mischief related to the debug macros and that is the abuse of <a class="el" href="rave__debug_8h.html#aa9b0782016fc3e4ecf40544f32be34a2">RAVE_ASSERT</a>. This macro is currently not possible to deactivate or disable in any way. By using this macro you have actually set up a contract on your code that says that unless the given criteria are fulfilled, I will crash the system.</p>
<p >Some people are against this type of behaviour since it forces a running system to dump instead of trying to recover or ignoring the recognized problem. The problem is actually that these macros can be used improperly and in that case they are really, really bad. If they are used with caution you might actually gain from them instead as they will give you an immediate information on where the problem occured instead of having a system that runs a bit further and then crashes for unknown reasons.</p>
<p >A good example on how to use the assert: </p><pre class="fragment">static int MyObject_setSize(MyObject_t* self, int sz) {
  RAVE_ASSERT((self != NULL), "self == NULL");
  self-&gt;sz = sz;
  return 1;
}
</pre><p >Here we say that if you pass in a self-pointer that is NULL, then there is something fundamentally wrong in your code.</p>
<p >A bad example on assert usage: </p><pre class="fragment">static int MyObject_setSize(MyObject_t* self, int sz) {
  RAVE_ASSERT((sz &gt; 0 &amp;&amp; sz &lt; 10), "sz &lt;= 0 or sz &gt;= 10");
  self-&gt;sz = sz;
  return 1;
}
</pre><p >Here, on the other hand, we say that if you try to set a value that not is in the interval 1 - 9, you should crash the system. This might be a bit harsh, but, as usual, it's a matter of taste.</p>
<p >Personally, I would have implemented it like this: </p><pre class="fragment">static int MyObject_setSize(MyObject_t* self, int sz)
{
  int result = 0;
  RAVE_ASSERT((self != NULL), "self == NULL");
  if (sz &gt; 0 &amp;&amp; sz &lt; 10) {
    self-&gt;sz = sz;
    result = 1;
  }
  return result;
}
</pre><p >This way I would have ensured that nobody atempts to call the object without the object itself and if someone is trying to set a value outside 1 - 9, I will return 0 instead of 1.</p>
<p >With this knowledge, it is time to take a look at the RAVE objects that are currently implemented and that are therefore at your disposal.</p>
<p ><a class="el" href="rave_cobjects.html">RAVE C Objects</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
