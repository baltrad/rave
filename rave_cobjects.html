<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAVE: RAVE C Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RAVE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">RAVE C Objects </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >On the previous page, we gave a brief overview on how you are supposed to work with the different support macros and functions we have delivered in the system.</p>
<p >Let's take a look at some of the objects we have at our disposal.</p>
<ul>
<li><a class="el" href="rave__datetime_8h.html#a0f026ad0c8d46cc2398cd19e75ea1bec">RaveDateTime_t</a> This is a very simple object that provides the user with two different members, time and date. As is specified in the header file, the date should be specified in the format YYYYMMDD and the time should be specified in HHmmss. It is quite straight forward in usage. <pre class="fragment">#include "rave_datetime.h"

static void somefun(void)
{
  RaveDateTime_t* datetime = RAVE_OBJECT_NEW(&amp;RaveDateTime_TYPE);
  if (datetime != NULL) {
    RaveDateTime_setDate(datetime, "20091010");
    RaveDateTime_setTime(datetime, "100000");
  }
  ...
  RAVE_OBJECT_RELEASE(datetime);
}
</pre> What happens if you specify a badly-formatted date or time, or any other oddity? Try for yourself by checking the return value from <a class="el" href="rave__datetime_8h.html#aaaa9dcc11b4d27be85091410acce6a7a">RaveDateTime_setDate</a> and <a class="el" href="rave__datetime_8h.html#a0c84609cf6a4c0ac80776a06f77eb83c">RaveDateTime_setTime</a> ... or you could read the documentation.</li>
<li><a class="el" href="rave__data2d_8h.html#a0b0fe70d8fa4d22a1efcb54a5239bfee">RaveData2D_t</a> This object is a bit more interesting since it provides support for a two-dimensional data array. It is used internally by both <a class="el" href="polarscan_8h.html#ab18af0ebcfc65c3148c7e8bee5455c57">PolarScan_t</a> and <a class="el" href="cartesian_8h.html#ab5a79e35a1b35277a4ce2abba3acada0">Cartesian_t</a>. When you are using this object you will get basic help on memory allocation, indexing and boundary checks. <pre class="fragment">#include "rave_data2d.h"

static void somefun(void)
{
  RaveData2D_t* data = RAVE_OBJECT_NEW(&amp;RaveData2D_TYPE);
  if (data != NULL) {
    if (RaveData2D_createData(data, 10, 10, RaveDataType_UCHAR)) {
      RaveData2D_setValue(data, 2, 2, 10.0);
    }
  }
  RAVE_OBJECT_RELEASE(data);
}
</pre> All setting and getting of data is actually done as doubles and the casting is done inside the functions. So, if you pass in a double that is &gt; 255 into the above call, then the value in the data array will be set to 255.</li>
<li><a class="el" href="raveobject__list_8h.html#abdac48af2ac58989ba91c33c2a1c79d0">RaveObjectList_t</a> A list supporting RAVE objects. It manages the reference counts and ensures that all objects are released upon destruction of the list. A small caveat: if any objects are passed to the list and these objects are not cloneable, then, if this list is cloned, the non-cloneable objects will be ignored. <pre class="fragment">#include "raveobject_list.h"

static void somefun(RaveObjectList_t* list)
{
  int len = RaveObjectList_size(list);
  int i = 0;
  for (i = 0; i &lt; len; i++) {
    RaveCoreObject* object = RaveObjectList_get(list, i);
    ....
    RAVE_OBJECT_RELEASE(object);
  }
}
</pre> Currently, we only support size and indexing, but eventually we are going to introduce an iterator as well.</li>
<li><a class="el" href="rave__list_8h.html#ad2ea2f1cc27c63aa76beb80b6535c3ef">RaveList_t</a> A basic list for storing pointers or values or whatever. It takes void pointers as list entries. However, it will not destroy any item for you when it is destroyed; that is up to the user. <pre class="fragment">#include "rave_list.h"

static void somefun(void)
{
  RaveList_t* list = RAVE_OBJECT_NEW(&amp;RaveList_TYPE);
  ...
  RaveList_add(list, ptr);
  ...
  while ((ptr = RaveList_removeLast(list)) != NULL) {
    RAVE_FREE(ptr);
  }
  
  RAVE_OBJECT_RELEASE(list);  
}
</pre></li>
</ul>
<p >That's the basic objects that only are there for making life a bit easier. We have a number of objects that are more interesting when working with radar data (or any other data) for that matter.</p>
<ul>
<li><a class="el" href="projection_8h.html#a377e7436c2aa8b08cf81603ee53bef26">Projection_t</a> This is a wrapper around PROJ.4. This object requires initialization after it has been created since it needs to know what projection definition it should support. <pre class="fragment">#include "projection.h"

static void somefun(void)
{
  Projection_t* p1 = RAVE_OBJECT_NEW(&amp;Projection_TYPE);
  Projection_t* p2 = RAVE_OBJECT_NEW(&amp;Projection_TYPE);
  double x = 0.0L, y = 0.0L;
  if (!Projection_init(p1, "stere", "my projection", "+proj=stere +ellps=bessel +lat_0=90 +lon_0=14 +lat_ts=60 +datum=WGS84")) {
    goto error;
  }
  if (!Projection_init(p2, "lonlat", "another projection description", "+proj=longlat +ellps=WGS84 +datum=WGS84")) {
    goto error;
  }
  x = 60.0 * M_PI/180.0;
  y = 14.0 * M_PI/180.0;
  if (!Projection_transform(p2, p1, &amp;x, &amp;y, NULL)) {
    goto error;
  }
  fprintf(stderr, "Surface coordinates %f, %d\n", x, y);
error:
  RAVE_OBJECT_RELEASE(p1);
  RAVE_OBJECT_RELEASE(p2); 
}
</pre> This code shows how you are able to translate a lon/lat coordinate into a surface coordinate represented by the stereographic projection p1. The most interesting function in this class is Projection_transform that will ensure that datum changes will be performed as long as +datum= has been specified. For further information on the usage, please refer to PROJ.4 documentation.</li>
<li><a class="el" href="area_8h.html#a684f43f037f8102185d9a7585080b7e8">Area_t</a> An area definition describing a surface. It contains corner coordinates, what projection it is defined by, what x/y - size and x/y - scale. So, it is quite useful if you are planning to create a Cartesian product or similar.</li>
</ul>
<p >Currently we have three different products that define the basic needs when working with radar data. Instead of writing some examples on how these are used, a list of the other objects will be presented below and at the end a simple main program that creates a PPI will be shown.</p>
<ul>
<li><a class="el" href="cartesian_8h.html#ab5a79e35a1b35277a4ce2abba3acada0">Cartesian_t</a> This class represents a Cartesian product, i.e. one or more two-dimensional surface images that are defined by a area extent, projection and the other bits that are defined in an <a class="el" href="area_8h.html#a684f43f037f8102185d9a7585080b7e8">Area_t</a>.</li>
<li><a class="el" href="polarscanparam_8h.html#aaf44d7db9941f6f7e9a9116fcb28e8dd">PolarScanParam_t</a> This class represents a physical parameter (variable) measured by the radar for a given scan of the horizon. This object contains one such parameter and any number of supporting quality datasets.</li>
<li><a class="el" href="rave__field_8h.html#a54b17ce798506570a3d68f25207e3730">RaveField_t</a> This class is a generic container for holding a dataset. It is often used (and intended) for representing data quality as a so-called quality-indicator dataset.</li>
<li><a class="el" href="polarscan_8h.html#ab18af0ebcfc65c3148c7e8bee5455c57">PolarScan_t</a> This class represents one radar scan. I.e. one or more two-dimensional arrays defining the different quantities. This class may contain any number of <a class="el" href="polarscanparam_8h.html#aaf44d7db9941f6f7e9a9116fcb28e8dd">PolarScanParam_t</a> objects as long as they are all valid for the same scan of the horizon.</li>
<li><a class="el" href="polarvolume_8h.html#a275c1e5d1e61accfd21135da054ad086">PolarVolume_t</a> A polar volume is defined by a number of <a class="el" href="polarscan_8h.html#ab18af0ebcfc65c3148c7e8bee5455c57">PolarScan_t</a> objects and some basic information like <em>what</em>, <em>where</em> and <em>how</em> attributes. <br  />
</li>
</ul>
<p >Other than that we have a couple of utilities that are useful when working with the objects defined above.</p>
<ul>
<li><a class="el" href="rave__io_8h.html#a7d5e574535a94c690276d809dd8d0e3e">RaveIO_t</a> Basic loading and saving of products in the ODIM_H5 format.</li>
<li><a class="el" href="transform_8h.html#a10bafcb4feed71e79f60d1f0678c9642">Transform_t</a> Some product generator algorithms that might be useful.</li>
</ul>
<pre class="fragment">/**
 * Simple PPI generator example without any checks or controls.
 */
#include "rave_io.h"
#include "polarscan.h"
#include "cartesian.h"
#include "polarvolume.h"
#include "area.h"

/**
 * Arguments are: &lt;filename&gt; &lt;scan index&gt; &lt;areaid&gt;
int main(int argc, char** argv)
{
  RaveIO_t* raveio = RaveIO_open(argv[1]);
  PolarScan_t* scan = NULL;
  Cartesian_t* result = NULL;
  Area_t* area = NULL;
  
  if (RaveIO_getObjectType(raveio) == Rave_ObjectType_PVOL) {
    PolarVolume_t* volume = RaveIO_getObject(raveio);
    scan = PolarVolume_getScan(volume, atoi(argv[2]));
    RAVE_OBJECT_RELEASE(volume);
  }
  
  area = createArea(argv[3]); 
  
  result = createPPI(scan, area);
  
  raveio.setFilename("result.h5")
  raveio.setObject(result);
  raveio.save();
  
  RAVE_OBJECT_RELEASE(raveio);
  RAVE_OBJECT_RELEASE(scan);
  RAVE_OBJECT_RELEASE(area);
  return 0;
}
</pre><p >The above example may leave a couple of unanswered questions, but at least it shows how the system can be used. For example, the object <a class="el" href="transform_8h.html#a10bafcb4feed71e79f60d1f0678c9642">Transform_t</a> supports ppi/cappi/pcappi when writing this documentation but this might change in the future and hence, I leave it up to the reader of this document to check what APIs you have at your disposal.</p>
<p >We have covered the basics and some of the building blocks and now it is time to take a look at a real-life example that was performed when developing the new version of RAVE, <a class="el" href="converting_mean.html">A real-life example on converting existing averaging filter functionality</a>. This example provides a complete example of writing a C module and a Python wrapper for it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
