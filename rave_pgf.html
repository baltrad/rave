<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAVE: RAVE XML-RPC Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RAVE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">RAVE XML-RPC Server </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >The Remote Procedure Call (RPC) lets us run software remotely.</p>
<p >When combined with XML, RPC uses XML as the mechanism whereby information is transferred from server to/from client. In practise, an XML-RPC server exposes methods and functions that the client can run. This is what has been done with RAVE's XML-RPC server. In this section, the way in which the server works will be presented, along with the message format for generating processing data, and additional functionality.</p>
<h1><a class="anchor" id="pgf_terms"></a>
Terminology</h1>
<p >There are a few terms associated with the server that require defining in this context.</p>
<p >A <em>module</em> is a file containing software, either in Python or in C as a compiled shared object.</p>
<p >A <em>method</em> is the object-oriented term, ie. software functionality found in an instance of an object. Likewise, a <em>function</em> is functionality found in a module.</p>
<p >An <em>algorithm</em> is a piece of software containing functionality for processing data. For the purposes of this server, an algorithm is accessed through a function found in a module.</p>
<p >A <em>job</em> is an external request to process data.</p>
<p >A <em>registry</em> is a collection of information on algorithms, ie. what they are called, which modules and functions they are in, and what arguments they take. The registry in this server is stored to file and is found in $RAVEROOT/etc/rave_pgf_registry.xml. There is one registry <em>entry</em> for each algorithm.</p>
<h1><a class="anchor" id="pgf_sb"></a>
Server behavior</h1>
<p >When operated normally, this server is daemonized. It will receive client connections and correctly-formatted method calls (see <a class="el" href="rave_pgf.html#pgf_mf">"generate" use and message format</a>). If the server contains the correct method and arguments, then the server will run the method and return an appropriate response. The method used to process data is called <b>generate</b>, and this method will call individual data processing algorithms.</p>
<p >The internal chain of events when a call to <b>generate</b> is made is, slightly simplified, as follows:</p>
<ol>
<li>
Algorithm is looked up in the registry. </li>
<li>
Arguments are verified. </li>
<li>
Job is queued. </li>
<li>
Job is run. </li>
<li>
Result (written to tempfile) is injected in the baltrad-node through the DEX, <b>or</b> <em>something else</em> happens before the job terminates, without a result tempfile being injected. </li>
</ol>
<p >Log entries are written for each step, and each <b>generate</b> job is assigned its own unique ID.</p>
<p >If the server is stopped in a controlled fashion before the job queue is emptied, then the queue will be saved to XML file. This file will be read the next time the server starts, and the queue will be run then. The queue file is $RAVEROOT/etc/rave_pgf_queue.xml. A stub file is provided in the uninstalled RAVE distribution, and it can be copied to empty the queue "manually" when the server is not running.</p>
<p >Using XML to store entries in the job queue implies that no data or even the algorithms themselves are stored in memory as part of the queueing process. Instead, it is the <em>whereabouts</em> of the data and the algorithms that are stored. This means we are not sending data over the wire unnecessarily. It also means that modules containing algorithms will be garbage collected if they are not used for some time, and this keeps the server's memory footprint down.</p>
<p >If you want to add a new algorithm, you can register it with the server. Likewise, if you want to remove an algorithm, you can de-register it with the server. If the algorithm arguments remain unchanged but its module is changed (e.g. updated), the server will detect this automatically and reload it the next time it is called. This makes it possible to introduce changes during runtime, thereby improving system availability. Similarly to the job queue, the algorithm registry is stored to XML file. The registry doesn't contain the algorithm themselves, only their <em>whereabouts</em> and what arguments they take. A registry entry contains the following information:</p>
<ul>
<li>The name of the entry, ie. how it is identified by the <b>generate</b> method.</li>
<li>The module containing the algorithm.</li>
<li>The function in the module used to run the algorithm.</li>
<li>A free-text description of the algorithm.</li>
<li>The arguments used with the algorithm.</li>
</ul>
<p >The details on how to manage the registry are found in <a class="el" href="rave_pgf.html#pgf_registry">pgf_registry</a>.</p>
<h1><a class="anchor" id="pgf_mf"></a>
"generate" use and message format</h1>
<p >The exact format of the <b>generate</b> message is taken care of automatically by your XML-RPC library. The method call and its arguments are converted into XML and passed to the server by the library. Likewise, whatever information is returned to the client from the method will be sent over the wire in XML and then converted to native types by your client. It is not recommended that you write your own XML to interact with the server; use an existing library instead. With this in mind, we can focus on the method call and its arguments.</p>
<p >The method call <b>generate</b> takes three arguments, as follows:</p>
<pre class="fragment">generate(algorithm, files, arguments)
</pre><p >where</p>
<ul>
<li><b>algorithm</b> is a <em>string</em> identifying the processing algorithm to run. The corresponding entry will be looked up in the registry. Please follow our Java-esque naming convention for identifying algorithms.</li>
<li><b>files</b> is a <em>list</em> of input ODIM_H5 files. Even if there is only one input file, it must still be found in a list.</li>
<li><b>arguments</b> is a <em>list</em> of argument key-value pairs. Each argument key-value pair requires an item in the list, the first part being a <em>string</em> containing the argument's name, and the second is that argument's value. While the XML-RPC protocol allows the items in the list to be several different types, some of which can be considered exotic, we will only accept the <em>string</em> type.</li>
</ul>
<p >It is recommended that the argument keys are assigned names that are as ODIM-like as possible, for the sake of consistency.</p>
<p >An example of a properly-formatted call to <b>generate</b> that generates a 500 m CAPPI using a nearest-neighbor polar-to-cartesian transformation to a Cartesian surface with identifier "searl_gnom" would be:</p>
<pre class="fragment">generate("eu.baltrad.beast.cappi", ["inputfile.h5"], ["--transform=nearest", "--areaid=searl_gnom", "--prodpar=500"])
</pre><p ><b>It is absolutely critical that arguments are passed in the <em>exact</em> order that is expected by the algorithm.</b></p>
<p >When writing your own application code to interact with the server, calling <b>generate</b> in Python is done almost exactly as the example above:</p>
<pre class="fragment">import xmlrpclib

server = xmlrpclib.ServerProxy("http://host:port/RAVE")
response = server.generate("eu.baltrad.beast.cappi", ["inputfile.h5"], ["--transform=nearest", "--areaid=searl_gnom", "--prodpar=500"])
</pre><p >The same call from a Java client would look like this:</p>
<pre class="fragment">String algorithm = "eu.baltrad.beast.cappi";
String[] files = new String[]{"inputfile.h5"};
String[] arguments = new String[]{"--transform=nearest", "--areaid=searl_gnom", "--prodpar=500"};
Object[] parameters = new Object[]{algorithm, files, arguments};

XmlRpcClient client = new XmlRpcClient();
XmlRpcClientConfigImpl config = new XmlRpcClientConfigImpl();
config.setServerURL(new URL("http://host:port/RAVE");
client.setConfig(config);

client.execute("generate", parameters);
</pre><p >The response returned to the client from the server will be a string: either a simple "OK" or a Python traceback (string) if something has gone wrong. For example, if you ask <b>generate</b> to run an algorithm that isn't registered, you'll get something like:</p>
<pre class="fragment">Traceback (most recent call last):
  File "/opt/baltrad/rave/Lib/rave_pgf.py", line 240, in generate
    raise LookupError('Algorithm "%s" not in registry' % algorithm)
LookupError: Algorithm "bogus_algorithm" not in registry
</pre><h1><a class="anchor" id="pgf_interact"></a>
Interacting with the server</h1>
<p >Because you are interacting with an XML-RPC server, you must always consider this server to be on the network, even if it is run on the same computer. This means that all interaction with the server is performed through client connections, so the server's complete address must always be specified by the client. Keep in mind when formatting the host address that the prefix <b><a href="http://">http://</a></b> must exist, and that the URL's path must be <b>/RAVE</b>, e.g.</p>
<pre class="fragment">http://localhost:8085/RAVE
</pre><p >All command-line tools have a <b>-h</b> or <b>--help</b> option to print usage and help.</p>
<h2><a class="anchor" id="pgf_server"></a>
rave_pgf</h2>
<p >The server is started, stopped, and restarted using this command, e.g.</p>
<pre class="fragment">$ rave_pgf start
</pre><p >You can also check the server's status:</p>
<pre class="fragment">$ rave_pgf status
rave_pgf is running with PID 54491 and GID 54490
</pre><p >If you attempt to start a server that's already running:</p>
<pre class="fragment">$ rave_pgf start
pidfile /opt/baltrad/rave/config/rave_pgf_server.pid already exists. Daemon already running?
</pre><p >You can run the server in the foreground. In this case, server requests are logged to the terminal by default. For example, a successful POST followed by an unsuccessful one will look like this:</p>
<pre class="fragment">$ rave_pgf fg
localhost - - [27/Jul/2010 11:50:36] "POST /RAVE HTTP/1.0" 200 -
localhost - - [27/Jul/2010 11:50:59] "POST /RAVE/bogus_path HTTP/1.0" 404 -
</pre><p >This output is not the same thing as the system's own logger, and such messages are directed to /dev/null when the server is run as a daemon.</p>
<p >Stopping a server running in the foreground is done with ctrl-c (KeyboardInterrupt).</p>
<h2><a class="anchor" id="pgf_help"></a>
pgf_help</h2>
<p >This command is used to query the methods available on the server, and learn what arguments a method takes. To list available methods:</p>
<pre class="fragment">$ pgf_help --host http://localhost:8085/RAVE --list
Available methods:
Help
deregister
generate
register
system.listMethods
system.methodHelp
</pre><p >To learn more about a method:</p>
<pre class="fragment">$ pgf_help --host http://localhost:8085/RAVE --method generate
generate ("algorithm",[files],[arguments])
</pre><p >Note that this functionality is used to query the server's methods, not the algorithms in the registry called by the <b>generate</b> method.</p>
<h2><a class="anchor" id="pgf_registry"></a>
pgf_registry</h2>
<p >This command is used to add a new entry to the algorithm registry, remove an entry, update an entry, list all entries in the registry, and query the characteristics of an algorithm in the registry. For example, a server with only one algorithm in its registry:</p>
<pre class="fragment">$ pgf_registry --host http://localhost:8085/RAVE --list

Registered algorithms in RAVE:
debug           Reads the input file (first input file in the files list) and injects it into a baltrad-node. Just for debugging.
</pre><p >To remove an algorithm from the registry:</p>
<pre class="fragment">$ pgf_registry -r --host http://localhost:8085/RAVE --name debug
De-registered debug
</pre><p >If you try to remove an algorithm that isn't registered, you will get the same response. You can check whether the algorithm is registered using the &ndash;list option.</p>
<p >To add or update a registry entry, you need to know <em>exactly</em> which arguments the algorithm requires, and what <em>type</em> each argument is. When we refer to the <em>type</em>, we mean any of <b>string</b>, <b>int</b>, <b>float</b>, and <b>sequence</b>. The sequence type is commonly referred to as a <b>list</b> in Python and Java. These arguments are given to <a class="el" href="rave_pgf.html#pgf_registry">pgf_registry</a> as comma-separated string of argument names.</p>
<p >An example of re-registering the 'debug' algorithm that we de-registered above.</p>
<pre class="fragment">$ pgf_registry -a --host http://localhost:8085/RAVE --name debug --module
rave_pgf_debug --function debugme --description "Reads the input file (first 
input file in the files list) and injects it into a baltrad-node. Just 
for debugging."
Registered debug
</pre><p >The free-text given with <b>--description</b> must be within quotation marks. Due to its simplicity, this above example doesn't actually contain any arguments. An example of a registration containing two string and one int arguments:</p>
<pre class="fragment">$ pgf_registry -a --host http://localhost:8085/RAVE --name cappi --module 
rave_pgf_cappi --function cappi --strings "transform,areaid" --ints
"prodpar" --description "Generates a CAPPI product."
</pre><p ><b>The module being registered must be placed manually in the $RAVEROOT/Lib directory or the server's call to this algorithm will fail.</b> In this sense, the purpose of the registration procedure is twofold: 1) we want to register algorithms without shutting down the server, 2) we want to register algorithms in a controlled manner.</p>
<p >Note that registering an algorithm with the same name as an existing registry entry will overwrite that entry!</p>
<p >Currently, it is possible to edit the XML file containing the registry, but this can only be done when the server is not running. This strategy is not recommended, because syntax errors may prevent the registry from loading properly when the server is started. It's better to register an algorithm "live" because the registration won't be effectuated unless <a class="el" href="rave_pgf.html#pgf_registry">pgf_registry</a> is used properly.</p>
<p >To query an algorithm's characteristics, e.g. the CAPPI we just registered:</p>
<pre class="fragment">$ pgf_registry -q --host http://localhost:8085/RAVE --name cappi

Algorithm: cappi
Description: Generates a CAPPI product.
Module: rave_pgf_cappi
Function: cappi
Argument names:
        Strings: transform,areaid
        Ints: prodpar
        Floats: None
        Sequences: None
</pre><h2><a class="anchor" id="pgf_init"></a>
Init script</h2>
<p >The server comes with an init script, for placement in e.g. /etc/init.d. This is useful in environments where automatic startup is necessary when the computer boots, where the server needs to be run from another user, and in situations where the server needs to be moved to another computer automatically. This script is found in $RAVEROOT/etc/rave_pgf.</p>
<p >The init script comes prepared for use with <b>chkconfig</b>, so that the computer can be configured to start the server automatically when it boots at certain run levels.</p>
<p >Note that the default user in this init script is <b>baltrad</b>, and this may require changing.</p>
<h1><a class="anchor" id="own_algorithm"></a>
Creating your own algorithms for the registry</h1>
<p >Adding your own algorithms to this server is possible by writing a function in a module and then registering it with the server according to <a class="el" href="rave_pgf.html#pgf_registry">pgf_registry</a>. The only strict rule is that the function called by <b>generate</b> must take as its arguments the trilogy (<em>algorithm</em>, <em>files</em>, <em>arguments</em>).</p>
<p >In principle, it is possible to write a shared object in C containing a function that takes the required arguments. It may be more convenient to write a Python module to do the same. It should be clarified, however, that shared objects in C must contain Python wrappers in order for them to be accessible to the Python intepreter. Please consult <a class="el" href="rave_capi.html">Introduction to the RAVE C APIs</a> for details on how to write a C module. In practise, the underlying functionality can be written as you like, and then the Python wrapper can be made relatively simple.</p>
<p >It is also possible to create a simple algorithm based on a shell-escape to a binary executable. This is generally not recommended, however, because doing this does not give us the control we expect from a production-grade system. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
