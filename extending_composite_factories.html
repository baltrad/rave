<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAVE: Extending composite factories</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RAVE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Extending composite factories</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="extending_compositing_introduction"></a>
Introduction</h1>
<p>Due to requirements for new variants of composite algorithms, let it be interpolated variants, other quality based ones or generating quantities that are derived from other ones we had to reconsider the compositing approach in order to support different scenarios. As described in <a class="el" href="Compositing.html">Compositing</a> the system is built from factories, managers, filters and other miscellaneous functionality. In this page we will go more in-depth on how to create new factories and what to consider when developing them.</p>
<h1><a class="anchor" id="extending_compositing_factories"></a>
Factories</h1>
<p>A factory can be seen as a producer that implements a number of features in order to return the requested composite. All factories can be seen as subclasses to <a class="el" href="compositegeneratorfactory_8h.html#a89b2b8763a8cefbe4dc47a06d0edb2f1">CompositeGeneratorFactory_t</a>. In reality, it's just function pointers that are redirected but the concept is similar. When implementing your own factory you will set the function pointers in the constructors and copy-constructors to ensure that the correct functions will be called.</p>
<p>The base class is defined in <a class="el" href="compositegeneratorfactory_8h.html#a89b2b8763a8cefbe4dc47a06d0edb2f1">CompositeGeneratorFactory_t</a> and is defined as</p>
<pre class="fragment">typedef struct _CompositeGeneratorFactory_t {
  RAVE_OBJECT_HEAD /**&lt; Always on top */
  COMPOSITE_GENERATOR_FACTORY_HEAD /**&lt; composite specifics */
} CompositeGeneratorFactory_t;
</pre><p>Then when defining your own structure you will use the same top-section and then extend your structure with all factory-specific items. For example, <a class="el" href="acqvacompositegeneratorfactory_8c.html#a8a5810d673a1d32d65188513708bf432">AcqvaCompositeGeneratorFactory_t</a> is defined as</p>
<pre class="fragment">typedef struct _AcqvaCompositeGeneratorFactory_t {
  RAVE_OBJECT_HEAD /**&lt; Always on top */
  COMPOSITE_GENERATOR_FACTORY_HEAD /**&lt; composite generator plugin specifics */
  CompositeEngine_t* engine; /**&lt;the engine */
  CompositeEngineOvershootingQcHandler_t* overshooting; /**&lt; the QC handler used for POO/Overshooting */
} AcqvaCompositeGeneratorFactory_t;
</pre><p>The relevant part when defining the factory is to set all function pointers that are defined by the <b>COMPOSITE_GENERATOR_FACTORY_HEAD</b>. These are</p>
<ul>
<li>getName - of type <a class="el" href="compositegeneratorfactory_8h.html#a88ec07bbd4434feb7e382184dfd4ed6f">composite_generator_factory_getName_fun</a> Returns the name of the factory, e.g. LegacyCompositeFactory. Is used when defining filters to know what factory to use.</li>
<li>getDefaultId - of type <a class="el" href="compositegeneratorfactory_8h.html#a94f0372711a0e4cb19ec4c5952e4c96f">composite_generator_factory_getDefaultId_fun</a> Returns the default id for this factory. Can be used when autogenerating filters etc. E.g. "legacy".</li>
<li>canHandle - of type <a class="el" href="compositegeneratorfactory_8h.html#abd9d0f6255ac9ea7103b26984620045a">composite_generator_factory_canHandle_fun</a> Checks the provided arguments if this factory can handle the request. Note that when using filters this function is not used.</li>
<li>setProperties - of type <a class="el" href="compositegeneratorfactory_8h.html#a3a28d78aaa48814ea921c5912531083b">composite_generator_factory_setProperties_fun</a> Sets the properties instance so that the factory can be initialized properly.</li>
<li>setProperties - of type <a class="el" href="compositegeneratorfactory_8h.html#a30dd4d83bf12554ed74d94b35df0da78">composite_generator_factory_getProperties_fun</a> Returns the properties that has been set in the factory.</li>
<li>create - of type <a class="el" href="compositegeneratorfactory_8h.html#a9984993a16abf4e36a8c3d573c43465a">composite_generator_factory_create_fun</a> This function creates an instance of self. This function is used by <a class="el" href="compositegenerator_8h.html#aacaab9018ec5c764d08f49036d7bffe4">CompositeGenerator_t</a> during generation to ensure that there is a unique instance during processing.</li>
<li>generate - of type <a class="el" href="compositegeneratorfactory_8h.html#a53680dbfdeb5070ca3636a319b7bd916">composite_generator_factory_generate_fun</a> Is called when executing the composite generation and as such is the factory method.</li>
</ul>
<p>All above methods has to be implemented by the factory but most of them is usually just one-liners. As mentioned earlier, the constructor and copy-constructor should ensure that the function pointers are set properly. In the following code snippet the start of ACQVAs constructor can be seen.</p>
<pre class="fragment">static int AcqvaCompositeGeneratorFactory_constructor(RaveCoreObject* obj)
{
  AcqvaCompositeGeneratorFactory_t* this = (AcqvaCompositeGeneratorFactory_t*)obj;
  CompositeQualityFlagDefinition_t* definition = NULL;

  this-&gt;getName = AcqvaCompositeGeneratorFactory_getName;
  this-&gt;getDefaultId = AcqvaCompositeGeneratorFactory_getDefaultId;
  this-&gt;canHandle = AcqvaCompositeGeneratorFactory_canHandle;
  this-&gt;setProperties = AcqvaCompositeGeneratorFactory_setProperties;
  this-&gt;getProperties = AcqvaCompositeGeneratorFactory_getProperties;
  this-&gt;generate = AcqvaCompositeGeneratorFactory_generate;
  this-&gt;create = AcqvaCompositeGeneratorFactory_create;
  this-&gt;engine = NULL;
  this-&gt;overshooting = NULL;
  this-&gt;engine = RAVE_OBJECT_NEW(&amp;CompositeEngine_TYPE);
  if (this-&gt;engine == NULL) {
    RAVE_ERROR0("Failed to create compositing engine");
    goto fail;
  }
  ....
}
</pre><p>Most function pointers will be set straight away since they usually are unique to the factory. At the end a member called engine is allocated which is a generic compositing engine that is executing a predefined sequence of operations that are typical for the composite creation in the rave toolbox. This engine will help when implementing the <a class="el" href="compositegeneratorfactory_8h.html#a53680dbfdeb5070ca3636a319b7bd916">composite_generator_factory_generate_fun</a> function and will be explained in <a class="el" href="#extending_compositing_factories_engine">Composite Engine</a>.</p>
<h2><a class="anchor" id="extending_compositing_factories_getName"></a>
getName</h2>
<p>As described earlier, <b>getName</b> returns a name that identifies the factory and can be seen as a class name. The implementation usually looks like</p>
<pre class="fragment">const char* AcqvaCompositeGeneratorFactory_getName(CompositeGeneratorFactory_t* self)
{
  return "AcqvaCompositeGenerator";
}
</pre><h2><a class="anchor" id="extending_compositing_factories_canHandle"></a>
canHandle</h2>
<p>The function <b>canHandle</b> should check the arguments for all relevant information that it needs to be able to produce a composite. The first thing to verify will most likely be to verify that the product name is supported, like PPI, PCAPPI or other product names like ACQVA. In the case of ACQVA we only verify that the product name is supported at the time of writing this documentation.</p>
<pre class="fragment">int AcqvaCompositeGeneratorFactory_canHandle(CompositeGeneratorFactory_t* self, CompositeArguments_t* arguments)
{
  const char* productid;

  RAVE_ASSERT((self != NULL), "self == NULL");
  if (arguments == NULL) {
    return 0;
  }
  productid = CompositeArguments_getProduct(arguments);
  if (productid == NULL || strcasecmp("ACQVA", productid) != 0) {
    return 0;
  }
  return 1;
}
</pre><h2><a class="anchor" id="extending_compositing_factories_generate"></a>
generate</h2>
<p>The generate function is the actual factory of the cartesian product. There are several approaches to implement this functionality but if you are using the <a class="el" href="#extending_compositing_factories_engine">Composite Engine</a> it might look something like</p>
<pre class="fragment">Cartesian_t* AcqvaCompositeGeneratorFactory_generate(CompositeGeneratorFactory_t* self, CompositeArguments_t* arguments)
{
  int i = 0, nobjects = 0;
  Cartesian_t* result = NULL;

  nobjects = CompositeArguments_getNumberOfObjects(arguments);
  for (i = 0; i &lt; nobjects; i++) {
    RaveCoreObject* obj = CompositeArguments_getObject(arguments, i);
    if (!RAVE_OBJECT_CHECK_TYPE(obj, &amp;PolarVolume_TYPE)) {
      RAVE_ERROR0("Acqva can only process volumes");
      RAVE_OBJECT_RELEASE(obj);
      return NULL;
    }
    RAVE_OBJECT_RELEASE(obj);
  }
  result = CompositeEngine_generate(((AcqvaCompositeGeneratorFactory_t*)self)-&gt;engine, arguments, (void*)self);
  if (result != NULL) {
    Cartesian_setProduct(result, Rave_ProductType_COMP);
  }
  return result;
}
</pre><h1><a class="anchor" id="extending_compositing_factories_engine"></a>
Composite Engine</h1>
<p>The composite engine is basically a boiler plate implementation of a composite generator where it is possible to exchange parts of the compositing with your own implementation. For example to replace how data is retrieved from the polar objects or how to set data in the generated composite. This replacement is done by setting various function pointers in the engine before starting the composite generation.</p>
<p>When calling <a class="el" href="compositeengine_8c.html#a9516c033f24f5c7de235c2edc9885b46">CompositeEngine_generate</a>, the first thing that happens is that a number of structures is created and initiated. For example <a class="el" href="structCompositeEngineObjectBinding__t.html">CompositeEngineObjectBinding_t</a> which is a binding between in-objects, projection pipelines and other information that is relevant during the processing. Another thing that happens is that the cartesian product is initiated with parameters and quality fields. After that a sequence of operations will be performed which will be described in the following subsections.</p>
<p>Before describing the different functions that can be overridden the basic concept for the generation will be described. The loop will originate from the cartesian area where the cartesian coordinates are translated into lon/lat that then will be used to navigate and retrieve the data from the source polar objects.</p>
<p>The first step calculates x and y pixel position in the cartesian product into the surface coordinates herex and herey. These surface coordinates will then be translated into a lon/lat coordinate. </p><pre class="fragment">  for (y = 0; y &lt; ysize; y++) {
    double herey = Cartesian_getLocationY(cartesian, y);
    for (x = 0; x &lt; xsize; x++) {
      double herex = Cartesian_getLocationX(cartesian, x);
      ....
      for (i = 0; i &lt; nbindings; i++) {
        if (!CompositeEngineFunction_getLonLat(self, extradata, &amp;bindings[i], herex, herey, &amp;olon, &amp;olat)) {
</pre><p>When the lon/lat coordinate has been calculated, the selectRadarData function is called to extract the relevant data to be used for the cartesian product.</p>
<pre class="fragment"> if (!CompositeEngineFunction_selectRadarData(self, extradata, arguments, &amp;bindings[i], i, olon, olat, cvalues, nentries)) {
    RAVE_ERROR0("Failed to get radar data");
 }
</pre><p>Finally, after the data has been retrieved from the polar objects the data is set in the cartesian product.</p>
<pre class="fragment">  CompositeEngineFunction_setRadarData(self, extradata, arguments, cartesian, olon, olat, x, y, cvalues, nentries);
</pre><h2><a class="anchor" id="extending_compositing_factories_engine_onstarting"></a>
onStarting</h2>
<p>The onStarting <a class="el" href="compositeengine_8h.html#af80143ea60c8e5845b09479a1b31b48b">composite_engine_onStarting_fun</a> will be called right before the loop over the cartesian area begins. When for example preparing the data for the calculations or if some precalculations has to be performed. An example on how it can be used is</p>
<pre class="fragment">static int NearestCompositeGeneratorFactory_onStarting(CompositeEngine_t* engine, void* extradata, CompositeArguments_t* arguments, CompositeEngineObjectBinding_t* bindings, int nbindings)
{
  NearestCompositeGeneratorFactory_t* self = (NearestCompositeGeneratorFactory_t*)extradata;
  int result = 0;
  RaveProperties_t* properties = CompositeEngine_getProperties(engine);
  if (!CompositeEngineFunctions_prepareRATE(engine, arguments, bindings, nbindings)) {
    RAVE_ERROR0("Failed to prepare RATE coefficients");
    goto fail;
  }
  CompositeEngineQcHandler_initialize(self-&gt;overshooting, extradata, properties, arguments, bindings, nbindings);

  result = 1;
fail:
  RAVE_OBJECT_RELEASE(properties);
  return result;
}
</pre><h2><a class="anchor" id="extending_compositing_factories_engine_onfinished"></a>
onFinished</h2>
<p>The onFinished <a class="el" href="compositeengine_8h.html#a3ee5e6c30f0e4358b01eba4dc5beb62e">composite_engine_onFinished_fun</a> is called after the actual compositing loop has been executed and is the final step during the composite generation. This is a good place to put cleanup of various files and other miscellaneous data that has been created during the compositing.</p>
<h2><a class="anchor" id="extending_compositing_factories_engine_getlonlat"></a>
getLonLat</h2>
<p>Used to calculate the longitude and latitude from the surface coordinates. This can be practical to use if you are interested in developing an alternative approach to nearest when identifying coordinates.</p>
<h2><a class="anchor" id="extending_compositing_factories_engine_selectradardata"></a>
selectRadarData</h2>
<p>This is the function that fetches the value that should be used in the composite. Since the user might want to create more than parameter during the process it is important to observe that cvalues is an array of parameter information and that the ncvalues is the number of elements in the array. See description of <a class="el" href="compositeengine_8h.html#a0b14aadd4bccd6e15ef69757fab8cb02">composite_engine_selectRadarData_fun</a> for more information.</p>
<p>A typical example on how it can be used is in the ACQVA generation where the data is selected based on hight above ground together with a specific quality field instead of the traditional compositing techniques used in radar products.</p>
<pre class="fragment">static int AcqvaCompositeGeneratorFactoryInternal_selectRadarData(CompositeEngine_t* engine, void* extradata, CompositeArguments_t* arguments, 
  CompositeEngineObjectBinding_t* binding, int index, double olon, double olat, struct CompositeEngineRadarData_t* cvalues, int ncvalues)
{
  double dist = 0.0, maxdist = 0.0;
  AcqvaCompositeGeneratorFactory_t* self = (AcqvaCompositeGeneratorFactory_t*)extradata;

  dist = PolarVolume_getDistance((PolarVolume_t*)binding-&gt;object, olon, olat);
  maxdist = PolarVolume_getMaxDistance((PolarVolume_t*)binding-&gt;object);

  if (dist &lt;= maxdist) {
    double height=0.0, elangle=0.0;
    int ray=0, bin=0, eindex=0, cindex = 0;
    PolarNavigationInfo navinfo;
    if (AcqvaCompositeGeneratorFactoryInternal_findLowestUsableValue(self, (PolarVolume_t*)binding-&gt;object, olon, olat, &amp;height, &amp;elangle, &amp;ray, &amp;bin, &amp;eindex, &amp;navinfo)) {
      for (cindex = 0; cindex &lt; ncvalues; cindex++) {
        RaveValueType otype = RaveValueType_NODATA;
        double v = 0.0;
        if (strcasecmp("RATE", cvalues[cindex].name) == 0) {
          otype = PolarVolume_getConvertedParameterValueAt((PolarVolume_t*)binding-&gt;object, "DBZH", eindex, bin, ray, &amp;v);
          if (otype == RaveValueType_DATA) {
            v = CompositeEngineFunction_convertDbzToRate(binding, otype, v, DEFAULT_ZR_A, DEFAULT_ZR_B);
          }
        } else {
          otype = PolarVolume_getConvertedParameterValueAt((PolarVolume_t*)binding-&gt;object, cvalues[cindex].name, eindex, bin, ray, &amp;v);
        }
        if (otype != RaveValueType_NODATA) {
          if (cvalues[cindex].mindist &gt; height) {
            cvalues[cindex].mindist = height;
            cvalues[cindex].value = v;
            cvalues[cindex].vtype = otype;
            cvalues[cindex].navinfo = navinfo;
            cvalues[cindex].radarindex = index;
            cvalues[cindex].radardist = cvalues[cindex].navinfo.actual_range;
          }
        }
      }
    }
  }
  return 1;
}
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
